name: Build & Push Docker Image

on:
  workflow_call:
    inputs:
      CACHE_REGISTRY:
        type: string
        default: cache-registry.mrcr.io
      CONTEXT:
        type: string
        default: .
      DEFAULT_RUNNER:
        type: string
        default: self-hosted-general
      DOCKERFILE:
        type: string
        default: Dockerfile
      IMAGE_TAG:
        type: string
        default: ${{ github.ref_name }}-${{ github.run_number }}
      IMAGE_TAG_LATEST:
        type: string
        default: ${{ github.ref_name }}-latest
      LANG:
        type: string
        default: ""
      NO_CACHE:
        type: boolean
        default: false
      PUSH_IMAGE:
        type: boolean
        default: true
      REGISTRY:
        type: string
        default: 155215722524.dkr.ecr.eu-central-1.amazonaws.com
      REPOSITORY:
        type: string
        default: ${{ github.event.repository.name }}
      RUNNERS:
        type: string
        default: self-hosted-general
    secrets:
      ACCESS_TOKEN:
        required: true
      BUILD_ARGS:
        required: false

jobs:
  get-runners-list:
    name: Get runners list output
    runs-on: ${{ inputs.DEFAULT_RUNNER }}
    steps:
      - name: Create runners list output
        id: runners-list
        run: |
          import os

          runners = str("${{ inputs.RUNNERS }}".split(","))
          os.system(f'echo "matrix={runners}" >> $GITHUB_OUTPUT')
        shell: python
    outputs:
      matrix: ${{ steps.runners-list.outputs.matrix }}

  build-and-push-images:
    name: Build and push docker images
    needs: get-runners-list
    strategy:
      fail-fast: true
      matrix:
        runner: ${{ fromJson(needs.get-runners-list.outputs.matrix) }}
    runs-on: ${{ matrix.runner }}
    outputs:
      image_tag: ${{ steps.image-tags.outputs.image_tag }}
      image_tag_amd64: ${{ steps.image-tags.outputs.image_tag_amd64 }}
      image_tag_arm64: ${{ steps.image-tags.outputs.image_tag_arm64 }}
      image_tag_latest: ${{ steps.image-tags.outputs.image_tag_latest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3.1.0
      - name: Get cache options
        id: cache-options
        if: ${{ inputs.LANG }} != ""
        run: |
          import os

          options = {
              "go": {
                  "path": ["/go/pkg/mod", "/root/.cache/go-build", "/root/.cache/golangci-lint"],
                  "hash_file": "go.sum",
              }
          }

          PATH_KEY = "path"
          HASH_FILE_KEY = "hash_file"

          def set_cache_options(lang: str):
              if lang not in options:
                  os.system(f'echo "CACHE_CONFIG_READY={0}" >> $GITHUB_OUTPUT')
                  return
              try:
                  path = ",".join(options[lang][PATH_KEY])
                  hash_file = options[lang][HASH_FILE_KEY].strip()

                  if path != "" and hash_file != "":
                      os.system(f'echo "CACHE_LANG={lang}" >> $GITHUB_OUTPUT')
                      os.system(f'echo "CACHE_PATH={path}" >> $GITHUB_OUTPUT')
                      os.system(f'echo "CACHE_HASH_FILE={hash_file}" >> $GITHUB_OUTPUT')
                      os.system(f'echo "CACHE_CONFIG_READY={1}" >> $GITHUB_OUTPUT')
                  else:
                      raise KeyError
              except KeyError:
                  print(f'Cache config is incorrectly set for {lang} applications')
              except Exception as e:
                  print(e)
              finally:
                  os.system(f'echo "CACHE_CONFIG_READY={0}" >> $GITHUB_OUTPUT')

          set_cache_options("${{ inputs.LANG }}")
        shell: python
      - name: Get cache path option
        id: cache-path-option
        if: ${{ inputs.LANG }} != "" && ${{ steps.cache-options.outputs.CACHE_CONFIG_READY }} == "1"
        run: |
          path=$(echo -e "${{ steps.cache-options.outputs.CACHE_PATH }}" | tr ',' '\n' | awk NF)

          path="${path//'%'/'%25'}"
          path="${path//$'\n'/'%0A'}"
          path="${path//$'\r'/'%0D'}"

          echo "CACHE_PATH=$path" >> $GITHUB_OUTPUT
          echo "CACHE_CONFIG_READY=1" >> $GITHUB_OUTPUT
        shell: bash
      - name: Actions cache
        uses: actions/cache@v3.0.11
        if: ${{ inputs.LANG }} != "" && ${{ steps.cache-path-option.outputs.CACHE_CONFIG_READY }} == "1"
        with:
          path: |
            ${{ steps.cache-path-option.outputs.CACHE_PATH }}
          key: ${{ runner.os }}-${{ steps.cache-options.outputs.CACHE_LANG }}-${{ hashFiles('${{ steps.cache-options.outputs.CACHE_HASH_FILE }}') }}
          restore-keys: |
            ${{ runner.os }}-${{ steps.cache-options.outputs.CACHE_LANG }}-
      - name: Set up docker context for buildx
        id: buildx-context
        run: |
          docker context create builders
      - name: Set up docker buildx
        id: buildx
        uses: docker/setup-buildx-action@v2.2.1
        with:
          endpoint: builders
          version: v0.9.1
      - name: Login to docker registry
        uses: docker/login-action@v2.1.0
        with:
          registry: ${{ inputs.REGISTRY }}
      - name: Customize image list
        id: image-list
        run: |
          import os

          RUN_NUMBER = "${{ github.run_number }}"
          TAG, TAG_LATEST = "${{ inputs.IMAGE_TAG }}", "${{ inputs.IMAGE_TAG_LATEST }}"
          REGISTRY, REPOSITORY = "${{ inputs.REGISTRY }}", "${{ inputs.REPOSITORY }}"

          def create_image_tag(tag: str, is_tag_latest: bool = False) -> str:
              repository = f"{REGISTRY}/{REPOSITORY}"
              if '/' not in tag:
                  return f"{repository}:{tag}"
              else:
                  return f"{repository}:{'build-latest'}" if is_tag_latest else f"{repository}:{f'build-{RUN_NUMBER}'}"

          output_tag = create_image_tag(TAG)
          output_tag_latest = create_image_tag(TAG_LATEST, True)

          os.system(f'echo "IMAGE_TAG={output_tag}" >> $GITHUB_OUTPUT')
          os.system(f'echo "IMAGE_TAG_LATEST={output_tag_latest}" >> $GITHUB_OUTPUT')
        shell: python
      - name: Build and push docker image
        id: docker-build
        uses: docker/build-push-action@v3.2.0
        with:
          build-args: |
            GITHUB_TOKEN=${{ secrets.ACCESS_TOKEN }}
            ${{ secrets.BUILD_ARGS }}
          cache-from: type=registry,ref=${{ inputs.CACHE_REGISTRY }}/${{ inputs.REPOSITORY }}:buildcache-${{ runner.arch }}
          cache-to: type=registry,ref=${{ inputs.CACHE_REGISTRY }}/${{ inputs.REPOSITORY }}:buildcache-${{ runner.arch }},mode=max
          context: ${{ inputs.CONTEXT }}
          file: ${{ inputs.DOCKERFILE }}
          no-cache: ${{ inputs.NO_CACHE }}
          push: ${{ inputs.PUSH_IMAGE }}
          tags: |
            ${{ steps.image-list.outputs.IMAGE_TAG }}-${{ runner.arch }}
      - name: Prepare image tags output
        id: image-tags
        if: ${{ inputs.PUSH_IMAGE }}
        run: |
          import os

          runner_arch = "${{ runner.arch }}"
          image_tag = "${{ steps.image-list.outputs.IMAGE_TAG }}"
          image_tag_latest = "${{ steps.image-list.outputs.IMAGE_TAG_LATEST }}"

          os.system(f'echo "image_tag={image_tag}" >> $GITHUB_OUTPUT')
          os.system(f'echo "image_tag_latest={image_tag_latest}" >> $GITHUB_OUTPUT')

          if runner_arch == "ARM64":
              os.system(f'echo "image_tag_arm64={image_tag}-{runner_arch}" >> $GITHUB_OUTPUT')
          elif runner_arch == "X64":
              os.system(f'echo "image_tag_amd64={image_tag}-{runner_arch}" >> $GITHUB_OUTPUT')
        shell: python

  build-and-push-manifest:
    name: Build and push docker manifests
    needs: build-and-push-images
    runs-on: ${{ inputs.DEFAULT_RUNNER }}
    if: ${{ inputs.PUSH_IMAGE }}
    steps:
      - name: Login to docker registry
        uses: docker/login-action@v2.1.0
        with:
          registry: ${{ inputs.REGISTRY }}
      - name: Build and push docker manifest
        env:
          IMAGE_TAG_LATEST: ${{ needs.build-and-push-images.outputs.image_tag_latest }}
          IMAGE_TAG_AMD_64: ${{ needs.build-and-push-images.outputs.image_tag_amd64 }}
          IMAGE_TAG_ARM_64: ${{ needs.build-and-push-images.outputs.image_tag_arm64 }}
          IMAGE_TAG: ${{ needs.build-and-push-images.outputs.image_tag }}
        run: |
          import os

          os.system('docker manifest create $IMAGE_TAG_LATEST $IMAGE_TAG_AMD_64 $IMAGE_TAG_ARM_64')
          os.system('docker manifest create $IMAGE_TAG $IMAGE_TAG_AMD_64 $IMAGE_TAG_ARM_64')

          IMAGE_TAG_AMD_64 = os.environ['IMAGE_TAG_AMD_64'].strip()
          IMAGE_TAG_ARM_64 = os.environ['IMAGE_TAG_ARM_64'].strip()

          if IMAGE_TAG_AMD_64:
            os.system('docker manifest annotate $IMAGE_TAG_LATEST $IMAGE_TAG_AMD_64 --arch amd64')
            os.system('docker manifest annotate $IMAGE_TAG $IMAGE_TAG_AMD_64 --arch amd64')

          if IMAGE_TAG_ARM_64:
            os.system('docker manifest annotate $IMAGE_TAG_LATEST $IMAGE_TAG_ARM_64 --arch arm64')
            os.system('docker manifest annotate $IMAGE_TAG $IMAGE_TAG_ARM_64 --arch arm64')

          os.system('docker manifest push $IMAGE_TAG_LATEST')
          os.system('docker manifest push $IMAGE_TAG')
        shell: python
